# Stacking Threads
- URL: https://www.netmeister.org/blog/thread-stacks.html
- Added At: 2025-10-30 14:28:25
- [Link To Text](2025-10-30-stacking-threads_raw.md)

## TL;DR
该文章分析了多线程程序中线程栈和线程控制块在进程内存中的布局差异，指出不同操作系统（如Linux、macOS、FreeBSD等）的线程栈放置位置与TCB管理方式显著不同。跨平台编程需注意内存布局随机性、栈位置不固定等特性，强调操作系统抽象层的复杂性。

## Summary
这篇文章探讨了多线程应用程序中线程栈和线程控制块（TCB）在进程内存布局中的位置和行为，并比较了不同操作系统的实现差异。

### 线程栈的布局
- **单线程进程内存布局**：通常分为高地址的栈（向下增长）、堆、数据段和低地址的文本段。
- **多线程应用**：每个线程拥有独立的栈，但共享进程空间。文章通过打印局部变量地址实验，分析线程栈的位置。
- **操作系统差异**：
  - **NetBSD和某些Linux版本**：线程栈以固定偏移量连续放置在主栈下方，偏移量等于栈大小加保护页大小。
  - **macOS**：线程栈位于主栈上方，偏移量固定，但栈大小可能小于系统限制。
  - **OpenBSD和OmniOS**：应用ASLR，线程栈位置随机，无固定偏移。
  - **FreeBSD**：线程栈位于主栈上方，但偏移随机。
- **细节说明**：实际地址可能因对齐、保护页或内核特性（如影子栈）而略有差异，可通过工具如`/proc/self/maps`或`vmmap`查看。

### 线程控制块（TCB）和线程本地存储（TLS）
- **TCB作用**：保存线程上下文（如栈指针、程序计数器），与TLS一起在线程创建时动态分配。
- **定位方法**：通过线程指针寄存器（如x86_64的`%fs`、arm64的`%tpdir_el0`）获取TLS地址，需内联汇编代码（非跨平台友好）。
- **操作系统实现对比**：
  - **NetBSD**：TCB分组放置，线程栈随机但后续线程连续。
  - **Linux**：TCB嵌入线程栈内部，位于栈高地址下方。
  - **macOS**：TCB位于线程栈上方224字节处。
  - **OpenBSD**：TCB和线程栈位置完全随机。
  - **FreeBSD**：TCB在堆下方向上增长，线程栈位于TCB下方但仍在主栈上方。
  - **OmniOS**：TCB连续放置，但线程栈随机，且可能重用已终止线程的栈空间。

### 总结
- 进程虚拟内存布局比简化模型复杂，不同操作系统的抽象实现存在显著差异。
- 文章强调计算机科学中层次抽象的重要性，并提示未来可能探讨参数传递和共享内存等主题。

实验代码和图表辅助说明了不同系统的内存排列，突出了跨平台编程的挑战。
