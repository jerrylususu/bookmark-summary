# A Survey of Dynamic Array Structures
- URL: https://azmr.uk/dyn/
- Added At: 2026-01-11 13:57:59
- Tags: #read #deepdive

## TL;DR
文章系统比较了六类动态数组结构，包括双倍复制数组、内存池数组、分块数组、链接块数组、树结构数组和指数数组，分析了各自的设计特点、优缺点及适用场景。作者倾向于使用内存池管理，强调需根据数据连续性、指针稳定性和内存效率等需求权衡选择。

## Summary
本文系统性地探讨了多种动态数组结构，总结了各自的设计特点、优缺点及适用场景。作者强调自身偏好使用内存池（arenas）而非通用分配器，并指出可能忽略通用分配中的细节。文章首先介绍了非完全动态的数组选项，然后深入分析真正的动态数组结构。

### 非完全动态数组选项
- **静态固定大小数组**：长度在编译时固定，适用于元素数量有合理上界的场景。优点包括易于推理、无动态分配、可内联存储；缺点包括内存浪费严重（若元素数量变化大）、难以处理用户控制长度的情况。
- **运行时固定大小数组**：长度在运行时确定，但分配后不增长。与静态数组功能相同，但通常需要额外间接寻址（可通过“struct hack”优化）。

### 动态数组结构
1. **realloc风格双倍复制数组**：
   - 维护容量可变的缓冲区，满时分配更大缓冲区（如2倍大小）并复制数据。
   - 优点：通用、数据连续、平摊O(1)增长、开发者熟悉。
   - 缺点：延迟峰值（扩容时需分配和复制）、元素指针不稳定（必须使用索引）、内存泄漏或需复杂分配器。
   - 分配模式问题：讨论了泄漏内存、使用内存池或通用分配器的权衡，指出非平凡分配可能破坏内存池的栈式生命周期管理。

2. **内存池支持数组**：
   - 利用虚拟内存保留大地址范围，仅在实际使用时分配物理内存。
   - 优点：地址空间连续、节省内存；缺点：需单独释放每个内存池，限制数组数量，且需避免推送操作交错。

3. **分块/桶数组**：
   - 将数组分成固定大小块，元数据（指针数组）管理块位置。
   - 优点：元素指针稳定、无需数据复制、缓存效率高、O(1)访问（若块大小为2的幂）；缺点：元数据O(N)开销、数据非连续、失去子切片和指针距离计算能力、元数据管理复杂。
   - 非连续数据问题：切片困难、距离计算无意义、可能引入内存错误（如与内存池栈操作交互时的use-after-free风险）。

4. **链接块数组**：
   - 块通过指针链接，类似链表（块大小可固定或动态）。
   - 优点：簿记简单、缓存友好、易于内存池分配、迭代简单；缺点：元数据O(N)、随机访问O(N)，适用于遍历密集型场景。

5. **树结构数组**：
   - 递归分层元数据（如B树）。
   - 优点：多数操作O(log N)、支持稀疏数据、结构共享；缺点：性能不突出、间接寻址多、缓存优化复杂、元数据和簿记开销大。

6. **指数数组（Xar）**：
   - 使用指针数组指向指数级增长的块。
   - 优点：簿记简单、单层间接寻址、易于内存池分配、O(1)元数据、访问高效；缺点：结构体较大、继承非连续数组问题、不支持稀疏数据。

### 总结比较
文章最后通过表格对比了各结构在指针稳定性、数据连续性、元数据、分配复杂度、内存池兼容性等方面的差异。总体而言，选择取决于具体需求，如数据连续性、指针稳定性、分配效率和生命周期管理。作者指出，没有单一结构适用于所有场景，需权衡优缺点。
