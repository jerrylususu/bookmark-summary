# Async, Sync, in Between
- URL: https://antfu.me/posts/async-sync-in-between
- Added At: 2025-03-28 16:00:19

## TL;DR


现代编程中，同步与异步函数混用易引发“异步蔓延”，导致代码级联修改和冗余。`quansync`通过生成器函数实现自适应执行：根据调用上下文动态选择同步或异步模式，减少代码重复及重构负担。但存在约120ns性能开销，且需显式设计兼容逻辑。该方案适用于需兼容同步/异步场景的库或插件系统。

## Summary


### 同步与异步函数的“颜色问题”  
在现代编程中，函数执行方式分为同步（阻塞）和异步（非阻塞），需严格区分避免混用。例如：  
- 异步函数可调用同步或异步函数  
- 同步函数无法直接调用异步函数，除非自身变为异步  
此限制导致代码重构困难，若底层函数需异步化，其所有调用链必须级联修改（“异步蔓延”），增加复杂性和工作量。  

---

### 问题表现与案例  
1. **依赖链的级联影响**：  
   - 若底层函数（如`loadFile()`）异步化，所有调用者需转为异步。  
   - 反向亦然：若某函数必须同步，其所有依赖需同步，否则需替换同步入口。  

2. **库维持双分支的负担**：  
   - 以`find-up`为例，需为同步/异步分别维护`findUp`和`findUpSync`逻辑，导致代码重复。  
   - 插件系统的异步钩子（如Markdown编译插件）强制主函数异步化，同步用户被迫使用await。  

---

### `quansync`解决方案  
通过引入“量子同步”概念（Quantum + Async），设计**可自适应同步/异步的函数**，在调用时根据上下文选择执行方式。  
主要特性与API：  
- **叠加态函数**：  
  - 使用生成器（Generator）函数分割执行逻辑，通过`yield*`控制流程，调用时选择同步或异步实现  
  - 构建时宏（如`unplugin-quansync`）支持用`async/await`语法，编译为生成器语法  
- **API分类**：  
  - **包装器**：显式分离同步/异步实现  
  - **生成器**：组合其他`quansync`函数，动态选择执行分支  

---

### 实现原理与局限  
1. **原理**：  
   - 生成器函数将代码拆分为多个执行块，由调用者决定是否等待异步操作。  
   - 同步上下文直接执行后续代码，异步则等待。  

2. **局限**：  
   - 需权衡性能开销：生成器引入约`120ns`延迟，对性能敏感场景需谨慎。  
   - 未完全消除颜色问题：`quansync`函数仍需显式设计，代码逻辑需兼容叠加态。  

---

### 适用场景与意义  
- **适用场景**：库设计需兼容同步/异步，或插件系统需灵活支持异步操作。  
- **优势**：减少代码重复，降低异步蔓延影响，提升库设计的灵活性。  
- **未来方向**：仍在探索阶段，需社区反馈优化。  

**相关工具**：[quansync](https://github.com/quansync-dev/quansync)，[unplugin-quansync](https://github.com/quansync-dev/unplugin-quansync)
