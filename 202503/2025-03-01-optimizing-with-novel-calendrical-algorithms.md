# Optimizing with Novel Calendrical Algorithms
- URL: https://jhpratt.dev/blog/optimizing-with-novel-calendrical-algorithms/
- Added At: 2025-03-01 11:08:06
- [Link To Text](2025-03-01-optimizing-with-novel-calendrical-algorithms_raw.md)

## TL;DR
作者通过性能审计，设计了新的日期时间算法，优化了`time` crate的性能，最终实现比现有算法快57.5%，且无分支，过程复杂但结果显著。

## Summary
1. **背景**：
   - 作者维护了`time` crate超过五年，期间不断添加和删除代码，但从未真正优化过算法。
   - 现有算法的速度“足够好”，但比其他crate慢。
   - 现在决定进行性能审计，主要是因为作者想尝试一些不同的东西。

2. **起点**：
   - 作者选择从`Date::to_calendar_date`方法开始优化，该方法接受年份和日期序数作为参数，返回`(year, month, day)`元组。

3. **现状**：
   - 现有实现使用了一个查找表，通过反向迭代确定月份和日期。
   - 代码示例展示了如何通过查找表计算月份和日期。

4. **初步优化尝试**：
   - **二分查找**：考虑到查找表是排序的，尝试使用二分查找，但由于表较小，线性查找更快。
   - **循环优化**：尝试用循环代替一系列`if`语句，但Rust的优化效果不如手动写出`if`语句。

5. **设计新算法**：
   - 作者决定从头设计一个新的日期时间算法，参考了Cassio Neri和Lorenz Schneider的论文，使用欧几里得仿射函数进行日期计算。
   - 设计新算法的原则：
     - **正确性**：必须正确，通过穷举法验证。
     - **性能**：必须比现有算法更快。
     - **仅使用整数**：避免浮点数操作。
     - **`const`兼容**：新算法必须是`const fn`。

6. **计算月份**：
   - 使用Gregorian日历的两个153天的月份块来计算月份。
   - 通过调整序数，避免了浮点数操作，最终设计了一个高效的月份计算公式。

7. **计算日期**：
   - 一旦知道了月份，计算日期相对简单，通过减去前几个月的天数来确定日期。
   - 使用类似的方法，设计了一个高效的日期计算公式。

8. **初步比较**：
   - 生成汇编代码进行比较，新算法生成的指令数量显著减少，并且是无分支的，性能更优。

9. **进一步改进**：
   - **月份计算**：通过分布式乘法和利用二进制位移优化月份计算公式。
   - **日期计算**：同样使用分布式乘法和位移优化日期计算公式。
   - **最终优化**：将序数转换为`u32`，避免了后续的类型转换，进一步优化了代码。

10. **最终代码**：
    - 给出了最终的代码实现，该实现比现有算法快57.5%，并且是无分支的。
    - 汇编代码显示，新算法的指令数量更少，且使用了优化后的常数。

11. **单独计算月份和日期**：
    - **月份单独计算**：提供了仅计算月份的代码，生成的汇编代码更简洁。
    - **日期单独计算**：提供了仅计算日期的代码，同样经过优化。

12. **总结**：
    - 作者成功设计了高性能、无分支且`const`兼容的算法，比现有实现快57.5%。
    - 未来希望继续设计类似的算法，虽然过程复杂，但结果值得。
