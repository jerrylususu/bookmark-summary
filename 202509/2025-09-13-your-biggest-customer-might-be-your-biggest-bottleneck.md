# Your Biggest Customer Might Be Your Biggest Bottleneck
- URL: https://densumesh.dev/blog/fair-queue/
- Added At: 2025-09-13 09:48:53
- [Link To Text](2025-09-13-your-biggest-customer-might-be-your-biggest-bottleneck_raw.md)

## TL;DR
博客讨论了FIFO队列在多租户系统中的缺陷，如任务阻塞问题，并提出了公平队列解决方案Broccoli，通过轮询调度确保任务公平处理，避免资源占用不均，已获得广泛关注。

## Summary
这篇博客讨论了在多租户系统中使用简单先进先出（FIFO）队列的局限性，并介绍了公平队列解决方案Broccoli的设计和实施。

### 问题背景
作者讲述了在Trieve公司遇到的一个实际案例：由于一个大型客户同时上传数百万份文档，导致FIFO队列被堵塞，其他客户的任务长时间等待，出现“吵闹邻居”问题，即一个租户占用过多资源，使其他租户无法得到服务。

### FIFO队列的缺陷
传统FIFO队列只按到达顺序处理任务，不考虑任务大小或客户需求。当一个大型任务进入队列时，后续的小型任务被阻塞，导致系统效率低下和公平性缺失。

### 传统解决方案的不足
- **限流客户**：通过限制客户发送消息的速率来缓解，但会迫使客户自行处理重试和队列管理，增加复杂性。
- **专用工作队列**：为大型客户分配独立资源，但资源利用率低（大型客户可能突发使用后闲置），且操作 overhead 高（如手动迁移任务）。

### 公平队列的引入
公平队列通过为每个客户维护独立队列，并结合轮询调度器，确保每个客户轮流获得处理机会。这种设计防止了资源饥饿：即使一个大客户有大量任务，小客户也能及时得到服务。

### Broccoli的实现
Broccoli是一个开源项目，基于两个核心组件：
- 每个客户有一个专用队列。
- 一个轮询调度器管理客户ID的顺序。

操作流程：
- **插入消息时**：将消息存入对应客户队列，如果该客户ID不在调度器中，则添加到末尾。
- **处理消息时**：调度器按顺序选择客户ID，从对应队列取一个任务处理。处理后，如果客户队列为空，则移除其ID；否则重新加入调度器末尾。
这种方法自平衡，高效且易于调试。

### 成果与推广
Broccoli发布后获得广泛关注，拥有15,000+下载量和400+ GitHub星标。项目还扩展支持了SurrealDB作为代理。作者鼓励读者尝试使用或参与讨论。
