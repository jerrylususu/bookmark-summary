# 从 React 看前端 UI 代码范式革命 | 风痕 · 術&思
- URL: https://hughfenghen.github.io/posts/2025/02/09/react-shaped-frontend-ui-paradigms/
- Added At: 2025-02-28 14:54:25
- [Link To Text](2025-02-28-从-react-看前端-ui-代码范式革命-风痕-·-術&思_raw.md)

## TL;DR
文章探讨了React如何引领前端UI代码范式的两次革命，从组件化到函数组件，Hooks API的引入推动了新的编程范式，但同时也带来了管理和优化的挑战。文章还讨论了不同框架如何改进Hooks API，并展望了未来前后端代码融合的趋势。

## Summary
1. **前言**：
   - 文章原计划讨论“为什么讨厌 React Hooks API”，但最终转向探讨 React 对前端 UI 代码范式的革命性影响。
   - React 作为两次前端范式革命的引领者，推动了整个前端领域的发展。
   - 本文主要讨论 Web UI 的基础表现形式，不涉及框架的具体用法或特性对比。

2. **往事**：
   - 2013 年 React 发布时，前端代码通常分为 html、js、css 三个文件，React 的 jsx 语法打破了关注点分离的设计思想。
   - 关注点分离思想基于浏览器使用三种不同类型的代码描述 UI 的结构、交互和样式，但随着前端页面复杂化，这种思想逐渐成为阻碍。
   - jQuery 提供了便捷的 DOM 操作方法，但难以追踪 DOM 变更，导致代码维护困难。
   - 旧范式（没有限制的操作 DOM）鼓励混乱，良好的编码规范和 CodeReview 难以在多成员、快速迭代项目中实现。

3. **第一次组件化革命**：
   - **背景**：前端页面复杂化，旧代码结构和范式阻碍生产力发展。
   - **思想**：组件化、数据驱动。
   - **武器**：jsx 语法。
   - **影响**：
     - 前端项目进入编译时代。
     - 组件化思想普及。
     - 数据驱动替代 DOM 操作。
   - React 通过组件化隔离复杂度，将结构和交互代码融合，开发者由操作 DOM 转向维护组件状态。

4. **2013 ～ 2019**：
   - React 创造了繁荣的社区，涌现大量基于 React 的组件库和低代码系统。
   - 类组件代码快速膨胀，状态值与展示和变更方法相隔甚远，形成新的关注点分离。
   - 类组件鼓励巨型组件，开发者倾向于在已有组件中添加代码，而非拆分组件。

5. **第二次函数组件革命**：
   - **背景**：前端项目复杂度增加，类组件代码膨胀。
   - **思想**：函数式组件 `UI = f(state)`。
   - **武器**：Hooks API。
   - **影响**：Hooks API 使函数组件成为新的 UI 代码范式。
   - Hooks API 在 js 语法限制下，以最简化的方式维持状态，状态为局部变量，与类组件的巨型状态相反。

6. **2019 ～ 至今**：
   - Hooks API 的简单运行机制带来问题：
     - 开发者需手动精确管理 useEffect 的依赖。
     - 常需使用 useMemo 或 useCallback 优化性能。
     - 闭包引用的状态可能过期。
     - setState 不是同步的，增加新手理解成本。

7. **它山之石，改良 Hooks API**：
   - **Solid.js**：
     - `createSignal` 将数据值换成获取数据值的函数，消除手动管理依赖和过期闭包。
     - 代价是状态变量需加括号调用。
   - **Vue.js**：
     - 使用 Proxy 实现依赖收集和状态变更监测，消除状态变更函数。

8. **当前理想化的 UI 范式**：
   - 理想的函数组件范式应包括标记变量为组件状态和避免重复运行组件函数体。
   - Svelte 通过编译期分析状态依赖，实现更简洁的状态管理。

9. **下一次（进行中？）革命**：
   - React 开始融合前端 UI 与后端表层服务，Next.js 项目允许在客户端直接调用服务端函数，简化客户端/服务端交互。
   - 未来可能实现前后端代码的融合管理。

10. **思考总结**：
    - **螺旋形上升**：反对将前后端代码融合视为“开历史倒车”，新事物在垂直方向上有进步。
    - **关注点分离**：关注点分离思想并没有错，Vue 的单文件组件融合了 html/js/css，同时保持了关注点分离。
    - **亲密性原则**：三次范式革命背后的驱动力是亲密性原则，代码组织应遵循亲密性原则，将亲密合作的代码放在一起。
