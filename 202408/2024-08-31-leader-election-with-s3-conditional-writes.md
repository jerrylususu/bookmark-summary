# Leader Election With S3 Conditional Writes
- URL: https://www.morling.dev/blog/leader-election-with-s3-conditional-writes/
- Added At: 2024-08-31 04:39:50

## TL;DR
本文介绍了在分布式系统中实现领导者选举的方法，特别是在对象存储如S3上利用条件写入实现分布式锁的机制。通过竞争创建锁文件，节点可以成为领导者执行特定任务，同时处理锁的过期和时钟漂移问题，确保系统的正确性和吞吐量。

## Summary
1. **分布式系统中的领导者选举**：
   - **背景**：在分布式系统中，例如将某些工作负载扩展到多个计算节点时，通常需要选择一个领导者来执行特定任务。否则，多个工作节点可能会重复执行同一任务，导致数据覆盖等问题。
   - **实现方法**：
     - **分布式锁**：所有节点竞争获取特定锁，只有一个节点能成功，该节点将成为领导者。
     - **现有系统支持**：如Apache ZooKeeper和Postgres通过Advisory Locks提供实现分布式锁的基础。

2. **对象存储中的领导者选举**：
   - **挑战**：如果应用仅涉及将数据写入对象存储（如Amazon S3、Google Cloud Storage或Azure Blob Storage），运行一个仅用于领导者选举的有状态服务可能会带来操作和财务上的负担。
   - **S3的条件写入支持**：直到最近，S3还不支持条件写入，这限制了在其上实现分布式锁的能力。AWS最近宣布S3支持条件写入，这为在S3上实现领导者选举提供了可能。

3. **S3条件写入的实现**：
   - **基本原理**：S3的`PutObject`操作现在支持可选的`If-None-Match`头，该头用于确保只有在目标桶中不存在相同键的文件时，写入操作才会成功。
   - **限制与优势**：虽然相比GCP和Azure提供的功能有限，但这足以实现领导者选举的锁机制。

4. **领导者选举算法**：
   - **基本思路**：节点竞争创建锁文件，成功创建的节点成为领导者。
   - **具体步骤**：
     1. 列出所有锁文件。
     2. 如果没有锁文件或最新的锁文件已过期：
        3. 增加epoch值并尝试创建新的锁文件。
        4. 如果锁文件创建成功，当前节点成为领导者，开始执行实际工作。
        5. 否则，返回步骤1。
     6. 否则，另一个进程已经是领导者，无需操作，定期返回步骤1。

5. **获取锁的实现**：
   - **关键点**：使用`If-None-Match`头并处理可能的`412 Precondition Failed`响应。
   - **示例代码**：使用AWS Java SDK实现锁的获取，处理412响应并抛出`LockingFailedException`。

6. **锁的过期处理**：
   - **领导者主动释放**：当前领导者可以将`expired`属性设置为`true`来释放锁。
   - **锁文件格式**：包含`expired`属性和`validity_ms`属性，定义锁的有效期。
   - **锁有效性检查**：领导者需要检查锁是否仍然有效，非领导者节点也可以检查最新锁是否有效。

7. **时钟漂移问题**：
   - **影响**：时钟漂移可能导致领导者误判锁的有效性，影响系统的正确性和吞吐量。
   - **解决方案**：通过在S3上创建临时文件并比较其创建时间与本地时间，或使用Amazon Time Sync Service来减少时钟漂移的影响。

8. **防止僵尸节点**：
   - **问题**：崩溃的领导者可能永远不会释放锁，导致无法选举新领导者。
   - **解决方案**：使用领导者epoch作为 fencing token，识别并丢弃过时的领导者请求。
   - **示例应用**：SlateDB通过上传文件的序列顺序并检测竞争写入者之间的冲突来实现这一机制。
