# The Linux Boot Process: From Power Button to Kernel
- URL: https://www.0xkato.xyz/linux-boot/
- Added At: 2025-11-02 13:33:40
- Tags: #read #linux #deepdive

## TL;DR
计算机启动过程从CPU复位、固件自检开始，逐步解压并加载内核，切换运行模式（实模式到保护模式再到长模式），最终移交控制权给操作系统内核。

## Summary
## 一、引导开始及固件阶段
1. **启动指令**：通电后，CPU复位进入实模式，跳转至复位向量地址`0xFFFFFFF0`，执行主板固件。
2. **固件类型**：
   - **BIOS**：进行硬件自检（POST），检查启动设备，读取首扇区（512字节，以`0x55AA`结尾）到内存`0x7C00`并执行。
   - **UEFI**：直接读取文件系统，加载更大引导程序，传递更多信息给操作系统。
3. **引导加载程序**：如GRUB，加载内核（含实模式设置程序与压缩内核）并填充启动参数结构，跳转至设置程序。

## 二、内核设置与模式切换
1. **设置程序工作**：
   - 初始化段寄存器（CS、DS、SS）和栈指针（SP）。
   - 清零BSS段（存放初始为零的全局变量）。
   - 可选启用早期串口打印（`earlyprintk`）。
   - 通过BIOS调用（如e820）获取内存布局。
2. **切换至保护模式**：
   - 禁用中断，初始化GDT（全局描述符表，采用平坦模型）和IDT（中断描述符表）。
   - 启用A20地址线（突破1MB地址限制），设置CR0寄存器PE位进入32位保护模式。
3. **切换至长模式（64位）**：
   - 启用分页（构建临时页表实现恒等映射），设置CR3指向页表。
   - 在EFER寄存器中设置LME位，通过远跳转进入64位长模式。

## 三、内核解压与地址处理
1. **准备工作**：
   - 检查运行位置，必要时自拷贝以避免重叠。
   - 加载简易IDT（处理页错误和NMI）。
   - 为内核、启动参数等建立恒等映射。
2. **解压内核**：
   - 调用`extract_kernel`函数，解压内核（支持gzip、xz等格式）。
   - 解析ELF格式，将代码和数据段复制到目标地址。
   - 若加载地址与编译地址不同，进行重定位修正指针。
3. **地址空间随机化（kASLR）**：
   - 为增强安全性，随机选择内核的物理基址和虚拟基址。
   - 避开关键区域（如解压程序、初始内存盘），使用硬件熵源生成随机偏移。
   - 可通过`nokaslr`参数禁用。

## 四、关键术语摘要
- **实模式**：16位模式，使用段地址+偏移量计算物理地址。
- **分页**：虚拟地址到物理地址的转换机制，早期使用2MB大页。
- **控制寄存器**：CR0（启用保护模式）、CR3（页表基址）、CR4（扩展功能）。
- **中断**：硬件/软件事件，早期仅处理页错误和NMI。
- **ELF**：内核文件格式，包含代码/数据段布局信息。
- **kASLR**：随机化内核地址空间布局，防止攻击。

整个过程通过逐步初始化硬件、切换CPU模式、解压内核并处理地址，最终跳转至内核入口点`start_kernel`，完成引导。
