# Agent Design Is Still Hard
- URL: https://lucumr.pocoo.org/2025/11/21/agents-are-hard/
- Added At: 2025-11-22 07:29:32
- Tags: #read #llm #deepdive #guide
- [Link To Text](2025-11-22-agent-design-is-still-hard_raw.md)

## TL;DR
2025年智能体开发经验显示，构建智能体仍面临多项挑战：推荐直接使用底层SDK以灵活处理工具调用与缓存；需显式管理缓存、注入引导信息强化任务推进，并通过子代理隔离失败；模型选择需兼顾成本与效能，测试尚无理想方案。整体看，智能体开发仍处精细探索阶段。

## Summary
本文基于作者在2025年11月对智能体（agent）开发的经验总结，核心观点是：构建智能体仍然充满挑战，主要体现在多个关键设计环节。以下分点结构化总结：

1. **SDK选择问题**：
   - 不推荐使用高层抽象SDK（如Vercel AI SDK），而是直接基于底层平台SDK（如OpenAI或Anthropic SDK）。原因包括：
     - 模型差异显著，高层抽象难以统一处理工具调用、缓存控制等需求。
     - 高层SDK可能引入消息格式冲突（如Anthropic的网页搜索工具破坏历史记录）和缓存管理不透明问题。
   - 当前阶段，直接控制智能体循环更灵活，成本效益更高。

2. **缓存管理**：
   - 显式缓存管理（如Anthropic的方式）优于自动缓存。优点包括：
     - 成本可控，缓存利用率更可预测。
     - 支持对话分支、上下文编辑等高级操作。
   - 实践中，作者在智能体循环中设置多个缓存点（如系统提示后、对话开始处），并动态注入信息以避免缓存失效。

3. **强化机制在循环中的应用**：
   - 每次工具调用后，可注入额外信息（如目标提醒、失败提示、状态更新）以引导智能体。
   - 自我强化工具（如Claude Code的待办列表回显）能有效推进任务。
   - 强化还用于处理环境变化或失败重试，例如提示智能体回退步骤。

4. **失败隔离**：
   - 通过子代理运行易失败任务，仅返回成功结果和失败摘要，避免主循环被干扰。
   - 上下文编辑可删除无关失败记录以节省令牌，但会破坏缓存，需权衡成本。

5. **子代理与共享状态**：
   - 虚拟文件系统作为共享存储层，确保工具（如代码执行、推理）能读写相同文件，避免任务死胡同。
   - 示例：图像生成工具输出文件后，代码执行工具可读取该文件进行后续处理。

6. **输出工具挑战**：
   - 专用输出工具（如发送邮件）难以控制语气和内容，且可能泄露中间步骤。
   - 使用次级LLM调整输出会增加延迟并降低质量，解决方法是强制检查输出工具是否被调用，未调用时注入强化提示。

7. **模型选择**：
   - 主循环优先选择Anthropic的Haiku和Sonnet（工具调用能力强、透明度高），Gemini模型适用于处理文档或图像的子任务。
   - 成本不仅取决于令牌价格，更高效的工具调用可减少总令牌消耗。

8. **测试与评估难点**：
   - 智能体的动态性使测试复杂，无法简单外部评估。需基于可观测数据或实际测试运行，但目前尚无满意方案。

9. **编码代理更新**：
   - 作者试用Amp代理，欣赏其子代理（如Oracle）与主循环的交互设计，认为其体现了实际使用需求。

10. **其他阅读推荐**：
    - 提倡最小化工具集（如用CLI工具替代复杂MCP），以减少上下文消耗。
    - 开源小库时代可能终结，因AI能自动生成简单工具。
    - Tmux技能可用于增强交互式系统的代理控制。

整体上，智能体开发仍处于探索阶段，需在SDK控制、缓存、强化、隔离失败等细节上精细设计，模型选择和测试也面临实际挑战。
