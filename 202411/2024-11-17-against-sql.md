# Against SQL
- URL: https://www.scattered-thoughts.net/writing/against-sql/
- Added At: 2024-11-17 07:02:31

## TL;DR
文章讨论了关系模型的优点和SQL的局限性，指出SQL的不具表达性、不可压缩性和非渗透性等问题，以及这些局限对整个行业的影响。文章提出需要重新思考数据库、查询语言和编程语言之间的界限，并从SQL的成功和错误中学习，设计新的语言。

## Summary
1. **关系模型的优点**：
   - **通用数据模型**：允许不同语言、不同机器和不同生命周期的程序之间进行合作。
   - **规范化**：允许更新数据而不必担心忘记更新派生数据。
   - **物理数据独立性**：允许更改数据结构和查询计划而不必更改所有查询。
   - **声明性约束**：清晰地传达应用程序的不变性并自动执行。
   - **无假数据依赖**：与命令式语言不同，关系查询语言没有由循环计数器和可别名指针创建的假数据依赖。
     - **现代机器友好**：数据可以重新排列以获得更紧凑的布局，甚至自动压缩。操作可以重新排序以获得高缓存局部性、流水线友好的热循环、SIMD等。
     - **易于自动并行化**。
     - **易于增量维护**。

2. **SQL的局限性**：
   - **不具表达性**：许多简单类型和计算无法表达，其他需要更多输入，结构脆弱。
   - **不可压缩**：代码无法通过提取相似结构来压缩，变量和函数的命名和使用受限。
   - **非渗透性**：扩展机制不标准化，扩展无法在不同数据库间共享。

3. **对整个行业的影响**：
   - **复杂性拖累**：复杂性对运行时和工具的质量和创新产生巨大拖累。
   - **应用层需求**：需要手动协调数据库和客户端的应用层，使得关系数据库的最佳特性大部分无用。

4. **SQL的替代方案**：
   - **核心信息**：通过替换SQL可以解锁大量价值，重新思考数据库、查询语言和编程语言之间的界限。

5. **SQL的不具表达性**：
   - **无法表达的例子**：如JSON、XML、正则表达式、窗口、多维数组等。
   - **冗长表达**：如连接操作的冗长语法。
   - **结构脆弱**：小的计算变化可能需要完全改变查询结构。

6. **SQL的不可压缩性**：
   - **变量**：标量值只能作为关系内的列分配，无法在不包含结果的情况下命名。
   - **函数**：重复计算的函数定义受限，直到SQL:99才引入标量函数。
   - **表达式替换**：SQL在类型和语法上破坏了表达式替换的原则。

7. **SQL的非渗透性**：
   - **语言层面**：通过成熟编程语言定义新类型和函数的机制不标准化。
   - **运行时层面**：创建新索引类型和存储方法的机制不标准化。
   - **接口层面**：每个数据库有完全不同的接口协议，不支持嵌套结构。

8. **复杂性拖累**：
   - **质量下降**：由于覆盖面广，无法全面做好所有工作，如子查询优化不佳。
   - **创新受限**：学术研究与实际应用之间缺乏平滑的管道。
   - **可移植性差**：规范过大且不完整，数据库扩展不标准。

9. **应用层的问题**：
   - **ORM的局限**：易受n+1查询问题和野蛮并发问题影响。
   - **手动管理**：手动转换查询为REST端点、管理缓存失效等导致错误。

10. **GraphQL和Firebase的成功**：
    - **GraphQL**：易于实现、缓存、嵌入其他语言，易于遵循外键并返回嵌套结果。
    - **Firebase**：简化架构，提供客户端查询的流更新、内置访问控制等。

11. **SQL之后的思考**：
    - **设计缺陷**：SQL语言的设计缺陷导致无库生态系统和繁重的规范，限制创新。
    - **接口缺陷**：SQL数据库接口的设计缺陷导致将大部分逻辑移至应用层。
    - **新语言的启示**：从SQL的成功和错误中学习，设计新的语言。

12. **FAQ**：
    - **为什么需要数据库中的JSON**：许多用例需要返回不适合单一关系的数据。
    - **SQL是唯一成功的关系语言**：SQL的成功并不意味着它是表达关系查询的自然方式。
    - **SQL的优点**：关系数据模型支持事务、逻辑数据独立性、计划优化等。
    - **JavaScript的改进**：JavaScript在过去几十年中有了显著改进，但SQL没有。
    - **SQL的历史**：SQL已经存在50多年，但COBOL的例子表明，注意到缺陷并设计更好的继任者是值得的。
    - **解决方案**：首先需要仔细分析和讨论现有系统的优缺点。
