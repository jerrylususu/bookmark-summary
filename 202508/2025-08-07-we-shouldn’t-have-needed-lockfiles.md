# We shouldn’t have needed lockfiles
- URL: https://tonsky.me/blog/lockfiles/
- Added At: 2025-08-07 14:23:53
- [Link To Text](2025-08-07-we-shouldn’t-have-needed-lockfiles_raw.md)

## TL;DR


文章认为依赖管理无需锁文件：通过固定顶层依赖版本并采用确定性解析（如Maven的就近优先策略），可确保子依赖恒定且无需额外记录；动态版本范围破坏构建可重复性。锁文件本质冗余，增加了维护成本，问题根源是对语义化版本控制的误解。

## Summary


本文讨论了软件依赖管理中锁文件（lockfiles）的必要性，指出其本质是不必要的复杂设计。依赖关系的版本确定可通过以下方式实现：  
1. **确定性解析**：顶层依赖版本固定后，所有子依赖版本根据其发布时声明的版本确定，无需额外记录。例如，项目依赖的 `libpupa 1.2.3` 固定依赖 `liblupa 0.7.8`，依赖树可**恒定**生成，无歧义。  
2. **版本范围问题**：使用动态版本范围（如 `liblupa ^0.7`）会导致构建结果随时间变化，依赖后续版本的发布状态。这破坏了可重复性，且开发者无法预见未来版本的兼容性，违背语义化版本的初衷。  
3. **锁文件的矛盾性**：实际开发中，锁文件被固化为固定版本，失去了动态更新的所谓“优势”，却引入额外维护成本。  

**反例对比**：  
Maven（Java生态）证明无需锁文件即可实现稳定依赖管理：  
- 通过**就近优先策略**解决冲突，如依赖树中存在 `d 1.0` 和 `d 2.0`，更接近根节点的版本会被选择。  
- 允许开发者手动覆盖依赖版本（如直接添加 `d 2.1`），无需等待所有子依赖更新。  
- 该机制保持确定性，且二十年大规模实践验证了其可行性。  

**结论**：锁文件本质是冗余设计，依赖管理可通过严格的版本固定义与解析策略实现可重复性，无需额外文件记录。复杂问题的根源在于对版本控制的误解，而非工具缺失。
